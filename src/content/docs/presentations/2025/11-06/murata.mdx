---
title: マイコンでのライブラリ開発概要
author: murata
---
import Author from '@components/Author.astro';
import ContentImage from '@components/ContentImage.astro';

<Author frontmatter={frontmatter} />

## はじめに

- 筆者はマイコン自体、ラズパイ以外ほとんど触ることがないので想像でおぎなうことがある。
- また、今回のゼミでは具体的なコードはほとんどない。

## 今回のライブラリ作成の方針

- ヒープ領域を使わない（スタック領域でなんとかする）
	- どのくらいヒープ領域が使えるか不明なため
- C++の目玉（？）であるSTLは使用しない
	- そもそもtemplateも使用しない
		- 結局、templateを使用するとバイナリサイズが読めないので

## 考え方

- Androidの`context`という考え方を利用する
	- いわゆる`Application Context`
	- シングルトンとして機能
		- 例
			- リソース(文字列、画像など)へのアクセス
			- データベースやファイルへのアクセス
			- 他のアプリケーションコンポーネントの起動
			- システムレベルのサービスへのアクセス

## 具体的には

- サンプルコードを記載する
```cpp
/*
* コンテキストの不完全な定義＝ポインタであれば使用可能
* いわゆるインターフェース
*/
// 通信関係のコンテキスト(EX:SSH、Bluetoothなど)
class ConnectionContext;

// 出力関係のコンテキスト(EX:コンソール画面に出力、M5Stack内蔵の画面に出力)
class WritableContext;

// システム全体のコンテキストを管理
class SystemContext
{
public:
    virtual ~SystemContext() = default;
    virtual ConnectionContext* getConnectionContext() const = 0;
    virtual WritableContext* getWritableContext() const = 0;
};

SystemContext* getContext();

// 例えばM5Stack用の実装(別ファイル)
class M5StackContext : public SystemContext
{
public:
    M5StackContext() {}
    ~M5StackContext() = default;
    // 本来はcppファイル内に実装を書く
    virtual ConnectionContext* getConnectionContext() const override { return nullptr; }
    virtual WritableContext* getWritableContext() const override { return nullptr; }
};

// コンテキストを取得するフリー関数(M5Stackの場合)
SystemContext* getContext()
{
    static M5StackContext context;
    return &context;
}

int main()
{
    SystemContext* context = getContext();
}
```
- System自身も不完全な定義にしてしまい、`GlobalContext`クラスを作成して、各マイコンごとのシステムに合わせるのもOK
	- むしろそっちのが都合が良い？
		- まあ上位のクラスなので付け替えるのは簡単ですね
- `context->getConnectionContext()->getBluetoothContext()->connect()`などとすると、コンテキストに合わせてBluetoothのコネクションができる
	- トップレベルを付け替えるとArduinoでもraspberry piでも同じ書き方でコネクションができる

