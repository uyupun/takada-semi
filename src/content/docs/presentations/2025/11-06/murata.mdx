---
title: マイコンでのライブラリ開発概要
author: murata
---
import Author from '@components/Author.astro';
import ContentImage from '@components/ContentImage.astro';

<Author frontmatter={frontmatter} />

## はじめに

- 筆者はマイコン自体、ラズパイ以外ほとんど触ることがないので想像でおぎなうことがある。
- また、今回のゼミでは具体的なコードはほとんどない。

## 今回のライブラリ作成の方針

- ヒープ領域を使わない（スタック領域でなんとかする）
	- どのくらいヒープ領域が使えるか不明なため
- C++の目玉（？）であるSTLは使用しない
	- そもそもtemplateも使用しない
		- 結局、templateを使用するとバイナリサイズが読めないので

## 考え方

- Androidの`context`という考え方を利用する
	- いわゆる`Application Context`
	- シングルトンとして機能
		- 例
			- リソース(文字列、画像など)へのアクセス
			- データベースやファイルへのアクセス
			- 他のアプリケーションコンポーネントの起動
			- システムレベルのサービスへのアクセス

## 具体的には

- サンプルコードを記載する
```cpp
/*
* コンテキストの不完全定義＝ポインタであれば使用可能
* いわゆるインターフェース
*/

// 通信関係のコンテキスト(EX:SSH、Bluetoothなど)
class ConnectionContext;

// 出力関係のコンテキスト(EX:コンソール画面に出力、M5Stack内蔵の画面に出力)
class WritableContext;

// システム全体のコンテキストを管理。ここにサウンド関係、センサ関係のインターフェースを追加する。
class SystemContext
{
public:
    virtual ~SystemContext() = default;
    virtual ConnectionContext* getConnectionContext() const = 0;
    virtual WritableContext* getWritableContext() const = 0;
};
```
```cpp
// 全体を把握するコンテキスト。いわば神様。
class GlobalContext
{
public:
    virtual ~GlobalContext() = default;
    // サンプルなので一つだけ
    virtual SystemContext* getSystemContext() const = 0;
};
```
```cpp
// 例えばM5Stack用の実装
class M5StackSystemContextImpl : public SystemContext
{
public:
    M5StackSystemContextImpl() {}
    ~M5StackSystemContextImpl() = default;
    // 本来はcppファイル内に実装を書く
    virtual ConnectionContext* getConnectionContext() const override { return nullptr; }
    virtual WritableContext* getWritableContext() const override { return nullptr; }
};
```
```cpp
// ここではM5Stackに特化した神様を配置
class GlobalContextForM5Stack : public GlobalContext
{
private:
    SystemContext* system_ctx;
public:
    // 配置new書くの面倒だからこう書く
    GlobalContextForM5Stack() : system_ctx(new M5StackSystemContextImpl()) {}
    ~GlobalContextForM5Stack() = default;
    SystemContext* getSystemContext() const { return  system_ctx; }
};

// コンテキストを取得するフリー関数
GlobalContext* getContext()
{
    static GlobalContextForM5Stack context;
    return &context;
}
```
```cpp
int main()
{
    auto context = getContext();
	// これはセグフォ引き起こすけど、こう書ける
    context->getSystemContext()->getWritableContext()->getScreen()->print("Hello, World"); // 出力先を意識せずprintしたり
}
```
[サンプルコード](https://wandbox.org/permlink/wPOxFU5d40myCffT)
- System自身も不完全な定義にしてしまい、`GlobalContext`クラスを作成して、各マイコンごとのシステムに合わせるのもOK
	- むしろそっちのが都合が良い？
		- まあ上位のクラスなので付け替えるのは簡単ですね
- `context->getConnectionContext()->getBluetoothContext()->connect()`などとすると、コンテキストに合わせてBluetoothのコネクションができる
	- トップレベルを付け替えるとArduinoでもraspberry piでも同じ書き方でコネクションができる

